---
title: "Constraints with branching"
author: "CulturalSystems"
date: "2024-02-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages and Functions

```{r}
library(igraph)
library(colorRamps)
library(extraDistr)
library(matrixStats)
library(doParallel)
library(foreach)

source("simFunctions.R")
source("loopFunctions.R")
```

## Set Parameters

```{r simulation parameters}
#### simulation parameters
params <- list(
  num_nodes = 16,               # size of the cultural systems (number of nodes)
  N = 100,                      # population size
  M = 10,                       # number of demonstrators
  timesteps = 5000,             # number of time steps in the simulation
  replicateSimulations = 2 ,    # number of simulations per parameter setting
  S = 0.99,                     # reliance on social learning; (1-S) is innovation rate
  reset_rate = 0.01,            # probability that an individual is replaced by a naive individual
  tree_layers = 5,              # number of layers in the tree
  alpha1 = 1,                   # Alpha parameter for the beta distribution used to generate the tree
  beta1 = 1,                    # Beta parameter for the beta distribution used to generate the tree 
  olderPref = 0,                
  windowSize = 1000             # parameters for plotting (number of time steps per printing event frequencies)
)


``` 

 ## Run Simulation

```{r}
### define a summary matrix with success of learning strategies
## it records the number of nodes, the branching factor, the learning strategy, the simulation replicates, and the mean payoff
strategySuccess<-matrix(nrow=0, ncol=9)

for (learningStrategy in c(0,1,2,3,4)){
  for (branching_factor in c(1,3,params$num_nodes)){
      ## generate rooted tree to represent the cultural system
      tree <- generate_rooted_tree_branching(params, branching_factor)
      ## for some tracking the distribution of traits across depths we need to know the depth of each node			
      nodeDepths<-1+distances(tree,v=1,to=V(tree),mode="out")
      maxNodeDepth<-max(nodeDepths)
      ## bookkeep the frequency of traits across tree depths (for checking stability over time)
      traitsAtDepth<-matrix(NA, nrow=params$timesteps, ncol=max(nodeDepths))
      
    
    ### start simulation
    numCores <- detectCores() - 1  # leave one core for other tasks
    cl <- makeCluster(numCores)
    registerDoParallel(cl)
    initResults <- matrix(numeric(0), ncol = 9) 

      results <- foreach(repl=1:params$replicateSimulations, .packages=c('igraph'), .combine='combineResults', .init=initResults) %dopar% {
 
      strategySuccess <- runsimulation(params, learningStrategy, repl, tree)

 
      ## simulation replicate is done
      strategySuccess
    }
    # Stopping the cluster after the parallelization step 
    stopCluster(cl)
     
    # add the results to the summary matrix
    strategySuccess <- rbind(strategySuccess, results)
  }
}
```
## Non-Parallel Version
For debugging and testing

```{r}
### define a summary matrix with success of learning strategies
## it records the number of nodes, the branching factor, the learning strategy, the simulation replicates, and the mean payoff
strategySuccess<-matrix(nrow=0, ncol=9)

for (learningStrategy in c(1,2)){
  print(learningStrategy)
  for (branching_factor in c(1,3,params$num_nodes)){
      ## generate rooted tree to represent the cultural system
      tree <- generate_rooted_tree_branching(params, branching_factor)
      ## for some tracking the distribution of traits across depths we need to know the depth of each node			
      nodeDepths<-1+distances(tree,v=1,to=V(tree),mode="out")
      maxNodeDepth<-max(nodeDepths)
      ## bookkeep the frequency of traits across tree depths (for checking stability over time)
      traitsAtDepth<-matrix(NA, nrow=params$timesteps, ncol=max(nodeDepths))
      
      for(repl in 1:params$replicateSimulations){
        print(repl)
        sumThisSimulation <- runsimulation(params, learningStrategy, repl, tree)
        strategySuccess <- rbind(strategySuccess, sumThisSimulation)
      }
  }
}
```


```{r}
## give names to the columns of the simulation summary matrix: number of nodes, the branching factor, the learning strategy, the simulation replicates, and the mean payoff
strategySuccess<-data.frame(strategySuccess)
names(strategySuccess)<-c('numNodes', 'branching_factor', 'tree_layers', 'alpha', 'beta', 'learningStrat', 'olderPref', 'repl', 'meanPayoff')
rownames(strategySuccess) <- NULL

stratCols<-c('black', 'deepskyblue', 'firebrick', 'violet', 'forestgreen')


## create an overview plot
par(mfrow=c(1,3), xaxs='r', mar=c(5,4,4,2),lend=1)


 for (brf in unique(strategySuccess$branching_factor)){
   b<-subset(strategySuccess,branching_factor==brf)
   boxplot(meanPayoff ~ learningStrat, data=b, col=stratCols, ylim=c(0,1.5))
  
   legend('topright', c('random', 'payoff', 'similarity', 'age', 'conformity'), col=stratCols, pch=15:19)
}

```


